const puppeteer = require('puppeteer');

/**
 * COMPREHENSIVE CSRF 403 DEBUGGING TEST
 * Tests all 5 hypotheses simultaneously with extensive logging
 */

class CSRF403DebugTest {
  constructor() {
    this.browser = null;
    this.page = null;
  }

  async setup() {
    console.log('ðŸ”§ SETTING UP CSRF DEBUGGING ENVIRONMENT...');
    this.browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    this.page = await this.browser.newPage();

    // Set realistic user agent (SAME AS OTHER DEBUG SCRIPTS)
    await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');

    // Configure page to handle cookies properly (SAME AS OTHER DEBUG SCRIPTS)
    await this.page.setExtraHTTPHeaders({
      Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'en-US,en;q=0.5',
      'Accept-Encoding': 'gzip, deflate',
      Connection: 'keep-alive',
      'Upgrade-Insecure-Requests': '1'
    });

    // Enable comprehensive logging
    this.page.on('console', (msg) => {
      if (msg.type() === 'error') {
        console.log(`âŒ CONSOLE ERROR: ${msg.text()}`);
      } else if (msg.text().includes('DEBUG') || msg.text().includes('ERROR') || msg.text().includes('SUCCESS')) {
        console.log(`ðŸ“ PAGE LOG: ${msg.text()}`);
      }
    });

    // Enable network request logging for ALL requests (SAME AS OTHER DEBUG SCRIPTS)
    this.page.on('request', (request) => {
      console.log(`ðŸš€ REQUEST: ${request.method()} ${request.url()}`);
      if (request.postData()) {
        console.log(`ðŸ“¤ REQUEST BODY: ${request.postData()}`);
      }
    });

    this.page.on('response', (response) => {
      console.log(`ðŸ“¥ RESPONSE: ${response.status()} ${response.url()}`);
    });
  }

  async teardown() {
    if (this.browser) await this.browser.close();
  }

  /**
     * HYPOTHESIS 1: CSRF token not being generated by backend
     */
  async testHypothesis1_CSRFTokenGeneration() {
    console.log('\nðŸ§ª HYPOTHESIS 1: CSRF Token Generation by Backend');
    console.log('='.repeat(50));

    try {
      // FOLLOW THE EXACT SAME AUTHENTICATION PATTERN AS OTHER DEBUG SCRIPTS
      console.log('\n[STEP 1] Navigating to login page...');
      await this.page.goto('https://109.123.238.197.sslip.io/login.html', { waitUntil: 'networkidle2' });

      // Login as manager
      console.log('\n[STEP 2] Logging in as manager...');
      await this.page.type('#username', 'manager');
      await this.page.type('#password', 'manager456');
      await this.page.click('#login-btn');

      // Wait for redirect and login
      await new Promise((resolve) => setTimeout(resolve, 3000));

      // Navigate to transaction page
      console.log('\n[STEP 3] Navigating to transaction page...');
      await this.page.goto('https://109.123.238.197.sslip.io/api/main/transaction', { waitUntil: 'networkidle2' });

      // Wait for page to load
      await new Promise((resolve) => setTimeout(resolve, 3000));

      const pageContent = await this.page.content();
      const csrfMetaTag = await this.page.evaluate(() => {
        const meta = document.querySelector('meta[name="csrf-token"]');
        return meta ? meta.getAttribute('content') : null;
      });

      console.log('ðŸ” Page contains "NEW TRANSACTION":', pageContent.includes('NEW TRANSACTION'));
      console.log('ðŸ” CSRF meta tag content:', csrfMetaTag);
      console.log('ðŸ” CSRF token is placeholder:', csrfMetaTag === '{{ an_actual_token }}');

      return {
        hypothesis: 'CSRF Token Generation by Backend',
        pageLoaded: pageContent.includes('NEW TRANSACTION'),
        csrfToken: csrfMetaTag,
        isPlaceholder: csrfMetaTag === '{{ an_actual_token }}',
        conclusion: csrfMetaTag === '{{ an_actual_token }}' ? 'FAILING - Token not generated' : 'WORKING - Token generated'
      };
    } catch (error) {
      return { hypothesis: 'CSRF Token Generation by Backend', error: error.message };
    }
  }

  /**
     * HYPOTHESIS 2: CSRF token not being injected into HTML
     */
  async testHypothesis2_CSRFTokenInjection() {
    console.log('\nðŸ§ª HYPOTHESIS 2: CSRF Token Injection into HTML');
    console.log('='.repeat(50));

    try {
      const pageSource = await this.page.content();
      const placeholderExists = pageSource.includes('{{ an_actual_token }}');
      const hexTokens = pageSource.match(/[a-f0-9]{64}/g);

      console.log('ðŸ” Page contains placeholder:', placeholderExists);
      console.log('ðŸ” Hex tokens found:', hexTokens?.length || 0);

      return {
        hypothesis: 'CSRF Token Injection into HTML',
        placeholderExists,
        hexTokensFound: hexTokens?.length || 0,
        conclusion: placeholderExists ? 'FAILING - Placeholder still present' : 'WORKING - Placeholder replaced'
      };
    } catch (error) {
      return { hypothesis: 'CSRF Token Injection into HTML', error: error.message };
    }
  }

  /**
     * HYPOTHESIS 3: Frontend not extracting CSRF token correctly
     */
  async testHypothesis3_FrontendExtraction() {
    console.log('\nðŸ§ª HYPOTHESIS 3: Frontend CSRF Token Extraction');
    console.log('='.repeat(50));

    try {
      const extractionTest = await this.page.evaluate(() => {
        const meta = document.querySelector('meta[name="csrf-token"]');
        const token = meta ? meta.getAttribute('content') : null;
        return {
          token,
          isPlaceholder: token === '{{ an_actual_token }}',
          length: token?.length
        };
      });

      console.log('ðŸ” Frontend extraction results:', extractionTest);

      return {
        hypothesis: 'Frontend CSRF Token Extraction',
        token: extractionTest.token,
        isPlaceholder: extractionTest.isPlaceholder,
        length: extractionTest.length,
        conclusion: extractionTest.isPlaceholder ? 'FAILING - Token is placeholder' : 'WORKING - Token extracted'
      };
    } catch (error) {
      return { hypothesis: 'Frontend CSRF Token Extraction', error: error.message };
    }
  }

  /**
     * HYPOTHESIS 4: CSRF token not being sent in API request headers
     */
  async testHypothesis4_RequestHeaders() {
    console.log('\nðŸ§ª HYPOTHESIS 4: CSRF Token in Request Headers');
    console.log('='.repeat(50));

    try {
      const apiTest = await this.page.evaluate(async () => {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');

        if (!csrfToken || csrfToken === '{{ an_actual_token }}') {
          return { error: 'No valid CSRF token available' };
        }

        const response = await fetch('/api/transactions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({
            masseuse_name: 'Test',
            service_type: 'Test',
            payment_method: 'Cash',
            start_time: '10:00 AM',
            end_time: '11:00 AM'
          })
        });

        const responseText = await response.text();
        return {
          status: response.status,
          body: responseText,
          token: csrfToken
        };
      });

      console.log('ðŸ” API test results:', apiTest);

      return {
        hypothesis: 'CSRF Token in Request Headers',
        status: apiTest.status,
        body: apiTest.body,
        token: apiTest.token,
        conclusion: apiTest.error ? 'FAILING - No valid token' : `WORKING - Request sent with status ${apiTest.status}`
      };
    } catch (error) {
      return { hypothesis: 'CSRF Token in Request Headers', error: error.message };
    }
  }

  /**
     * HYPOTHESIS 5: Backend CSRF validation failing
     */
  async testHypothesis5_BackendValidation() {
    console.log('\nðŸ§ª HYPOTHESIS 5: Backend CSRF Validation');
    console.log('='.repeat(50));

    try {
      // Analyze the response from the previous test
      const lastResponse = this.lastApiResponse;

      if (!lastResponse) {
        return {
          hypothesis: 'Backend CSRF Validation',
          error: 'No API response available',
          conclusion: 'Cannot determine validation status'
        };
      }

      let validationResult = 'UNKNOWN';
      if (lastResponse.status === 403) {
        if (lastResponse.body.includes('CSRF token required')) {
          validationResult = 'FAILED - CSRF token missing';
        } else if (lastResponse.body.includes('Invalid CSRF token')) {
          validationResult = 'FAILED - CSRF token invalid';
        } else {
          validationResult = 'FAILED - Unknown CSRF error';
        }
      } else if (lastResponse.status === 201 || lastResponse.status === 200) {
        validationResult = 'SUCCESS - CSRF validation passed';
      }

      return {
        hypothesis: 'Backend CSRF Validation',
        status: lastResponse.status,
        body: lastResponse.body,
        conclusion: validationResult
      };
    } catch (error) {
      return { hypothesis: 'Backend CSRF Validation', error: error.message };
    }
  }

  /**
     * RUN ALL HYPOTHESIS TESTS SIMULTANEOUSLY
     */
  async runAllTests() {
    console.log('ðŸš€ STARTING COMPREHENSIVE CSRF 403 DEBUGGING TEST');
    console.log('ðŸ§ª TESTING ALL 5 HYPOTHESES SIMULTANEOUSLY WITH EXTENSIVE LOGGING');
    console.log('='.repeat(80));

    try {
      await this.setup();

      // Run all hypothesis tests
      const h1 = await this.testHypothesis1_CSRFTokenGeneration();
      const h2 = await this.testHypothesis2_CSRFTokenInjection();
      const h3 = await this.testHypothesis3_FrontendExtraction();
      const h4 = await this.testHypothesis4_RequestHeaders();
      const h5 = await this.testHypothesis5_BackendValidation();

      // Store last API response for hypothesis 5
      this.lastApiResponse = h4.status ? { status: h4.status, body: h4.body } : null;

      // Generate analysis
      this.generateAnalysis([h1, h2, h3, h4, h5]);
    } catch (error) {
      console.error('âŒ TEST SUITE FAILED:', error);
    } finally {
      await this.teardown();
    }
  }

  generateAnalysis(results) {
    console.log('\nðŸ“Š COMPREHENSIVE ANALYSIS RESULTS');
    console.log('='.repeat(80));

    const working = results.filter((r) => r.conclusion?.includes('WORKING'));
    const failing = results.filter((r) => r.conclusion?.includes('FAILING'));

    console.log(`âœ… WORKING: ${working.length}/5`);
    console.log(`âŒ FAILING: ${failing.length}/5`);

    console.log('\nðŸ“‹ DETAILED RESULTS:');
    results.forEach((test, i) => {
      console.log(`\n${i + 1}. ${test.hypothesis}`);
      console.log(`   Status: ${test.error ? 'âŒ TEST FAILED' : (test.conclusion?.includes('WORKING') ? 'âœ… WORKING' : 'âŒ FAILING')}`);
      console.log(`   Conclusion: ${test.conclusion || test.error}`);
    });

    console.log('\nðŸ” ROOT CAUSE IDENTIFIED:');
    failing.forEach((test) => {
      console.log(`   - ${test.hypothesis}: ${test.conclusion}`);
    });
  }
}

// Run the test suite
async function main() {
  const test = new CSRF403DebugTest();
  await test.runAllTests();
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = CSRF403DebugTest;
